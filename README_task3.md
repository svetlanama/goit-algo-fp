# Завдання 3: Алгоритм Дейкстри з бінарною купою

## Опис
Програма реалізує алгоритм Дейкстри для знаходження найкоротших шляхів у зваженому графі, використовуючи бінарну купу (піраміду) для оптимізації вибору вершин. Алгоритм обчислює найкоротші шляхи від початкової вершини до всіх інших вершин графа.

## Встановлення залежностей
```bash
pip install -r requirements.txt
```

## Використання

### Запуск програми
```bash
python task3.py
```

### Режими роботи
1. **Демонстрація** - показує роботу алгоритму на зразковому графі
2. **Інтерактивний режим** - дозволяє створити власний граф та протестувати алгоритм
3. **Тестування** - автоматична перевірка правильності роботи алгоритму

## Технічні деталі

### Основні компоненти

#### 1. BinaryHeap
- Реалізація мінімальної бінарної купи
- Використовує Python's `heapq` модуль
- Оптимізує вибір наступної вершини для обробки

#### 2. WeightedGraph
- Представлення зваженого неорієнтованого графа
- Підтримка додавання вершин та ребер
- Зберігання координат для візуалізації

#### 3. DijkstraAlgorithm
- Основна реалізація алгоритму Дейкстри
- Використовує бінарну купу для оптимізації
- Знаходить найкоротші шляхи до всіх вершин

#### 4. GraphVisualizer
- Візуалізація графа з використанням NetworkX та Matplotlib
- Відображення найкоротших шляхів
- Показ відстаней до кожної вершини

### Алгоритм Дейкстри

1. **Ініціалізація**:
   - Встановлюємо відстань до початкової вершини = 0
   - Відстань до всіх інших вершин = ∞
   - Додаємо початкову вершину до бінарної купи

2. **Основний цикл**:
   - Витягуємо вершину з мінімальною відстанню з купи
   - Позначаємо її як відвідану
   - Перевіряємо всіх сусідів
   - Оновлюємо відстані та додаємо до купи, якщо знайдено коротший шлях

3. **Завершення**:
   - Коли купа порожня, алгоритм завершено
   - Відновлюємо шляхи через масив попередників

### Складність
- **Часова**: O((V + E) log V), де V - кількість вершин, E - кількість ребер
- **Просторова**: O(V) для зберігання відстаней та попередників

### Переваги використання бінарної купи
- Швидкий пошук мінімального елемента: O(log V)
- Ефективне оновлення пріоритетів
- Загальна оптимізація алгоритму

## Приклади використання

### Базове використання
```python
from task3 import WeightedGraph, DijkstraAlgorithm

# Створення графа
graph = WeightedGraph()
graph.add_vertex(1)
graph.add_vertex(2)
graph.add_vertex(3)
graph.add_edge(1, 2, 4)
graph.add_edge(2, 3, 2)
graph.add_edge(1, 3, 7)

# Запуск алгоритму Дейкстри
dijkstra = DijkstraAlgorithm(graph)
distances, predecessors = dijkstra.dijkstra(1)

print(f"Відстані: {distances}")
```

### Знаходження конкретного шляху
```python
path, distance = dijkstra.get_shortest_path(1, 3)
print(f"Шлях: {path}")
print(f"Відстань: {distance}")
```

## Особливості реалізації

- **Оптимізація**: Використання бінарної купи замість простого масиву
- **Візуалізація**: Автоматичне відображення графа та найкоротших шляхів
- **Гнучкість**: Можливість створення власних графів
- **Тестування**: Автоматичні тести для перевірки правильності
- **Інтерактивність**: Зручний інтерфейс для користувача

## Тестові дані

Програма включає два зразкові графи:
1. **Простий граф** (6 вершин) - для базового тестування
2. **Складний граф** (7 вершин) - для демонстрації складніших випадків

## Обробка помилок

- Перевірка існування вершин
- Валідація введених даних
- Обробка недосяжних вершин
- Захист від неправильного вводу
![task3.png](img%2Ftask3.png)