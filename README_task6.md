# Завдання 6. Жадібні алгоритми та динамічне програмування

## Опис

Програма `task6.py` реалізує два підходи для розв'язання задачі вибору їжі з найбільшою сумарною калорійністю в межах обмеженого бюджету:

1. **Жадібний алгоритм** - максимізує співвідношення калорій до вартості
2. **Динамічне програмування** - знаходить оптимальне рішення

## Постановка задачі

Дано набір страв з відомими вартістю та калорійністю. Потрібно вибрати такий набір страв, щоб:
- Сумарна вартість не перевищувала заданий бюджет
- Сумарна калорійність була максимальною

### Вхідні дані

```python
ITEMS = {
    "pizza": {"cost": 50, "calories": 300},
    "hamburger": {"cost": 40, "calories": 250},
    "hot-dog": {"cost": 30, "calories": 200},
    "pepsi": {"cost": 10, "calories": 100},
    "cola": {"cost": 15, "calories": 220},
    "potato": {"cost": 25, "calories": 350}
}
```

## Алгоритми

### 1. Жадібний алгоритм

#### Принцип роботи
1. Обчислює співвідношення калорій/вартість для кожної страви
2. Сортує страви за спаданням цього співвідношення
3. Послідовно додає страви, які вміщуються в бюджет

#### Переваги
- ✅ Швидкий виконання: O(n log n)
- ✅ Простий у реалізації
- ✅ Ефективний для великих наборів даних
- ✅ Мінімальне використання пам'яті

#### Недоліки
- ❌ Не завжди дає оптимальне рішення
- ❌ Може пропустити кращі комбінації

#### Приклад роботи
```
Співвідношення калорій/вартість:
  potato: 14.00 (350/25)
  pepsi: 10.00 (100/10)
  cola: 14.67 (220/15)
  hot-dog: 6.67 (200/30)
  hamburger: 6.25 (250/40)
  pizza: 6.00 (300/50)

Бюджет: 100
Вибір: potato (25) + cola (15) + pepsi (10) + hot-dog (30) = 80 грн, 870 кал
```

### 2. Динамічне програмування

#### Принцип роботи
1. Створює таблицю `dp[i][w]` - максимальна калорійність для перших i страв з бюджетом w
2. Заповнює таблицю за рекурентним співвідношенням:
   ```
   dp[i][w] = max(dp[i-1][w], dp[i-1][w-cost[i]] + calories[i])
   ```
3. Відновлює рішення шляхом зворотного проходу

#### Переваги
- ✅ Завжди дає оптимальне рішення
- ✅ Гарантована правильність
- ✅ Можна відновити точний набір страв

#### Недоліки
- ❌ Більша складність реалізації
- ❌ Вимагає більше пам'яті: O(n × W)
- ❌ Може бути повільним для великих бюджетів

#### Приклад роботи
```
Таблиця DP (фрагмент):
Бюджет:     0    5   10   15   20   25
Страва 0:   0    0    0    0    0    0
Страва 1:   0    0  100  100  100  100
Страва 2:   0    0  100  220  220  220
...

Відновлення: potato (25) + cola (15) + pepsi (10) + hot-dog (30) = 80 грн, 870 кал
```

## Структура програми

### Клас `FoodSelection`

```python
class FoodSelection:
    def __init__(self, items: Dict[str, Dict[str, int]] = None)
    def greedy_algorithm(self, budget: int, verbose: bool = True)
    def dynamic_programming(self, budget: int, verbose: bool = True)
    def compare_algorithms(self, budget: int)
    def visualize_comparison(self, budgets: List[int])
    def analyze_items(self)
```

### Основні методи

#### `greedy_algorithm(budget, verbose)`
- Реалізує жадібний алгоритм
- Повертає: (вибрані страви, загальна вартість, загальна калорійність)

#### `dynamic_programming(budget, verbose)`
- Реалізує динамічне програмування
- Повертає: (вибрані страви, загальна вартість, загальна калорійність)

#### `compare_algorithms(budget)`
- Порівнює результати обох алгоритмів
- Показує різницю в калорійності та часі виконання

#### `visualize_comparison(budgets)`
- Створює графіки порівняння для різних бюджетів
- 4 панелі: калорійність, час виконання, ефективність, перевага DP

## Використання

### Базове використання

```python
from task6 import FoodSelection

# Створення об'єкта
food_selection = FoodSelection()

# Жадібний алгоритм
items, cost, calories = food_selection.greedy_algorithm(budget=100)

# Динамічне програмування
items, cost, calories = food_selection.dynamic_programming(budget=100)

# Порівняння
food_selection.compare_algorithms(budget=100)
```

### Запуск програми

```bash
python task6.py
```

### Режими роботи

1. **Демонстрація алгоритмів**
   - Показує роботу обох алгоритмів на різних бюджетах
   - Включає аналіз страв та візуалізацію

2. **Інтерактивний режим**
   - Дозволяє створювати власні набори страв
   - Тестувати з різними бюджетами
   - Порівнювати результати

3. **Аналіз складності**
   - Теоретичний аналіз алгоритмів
   - Порівняння переваг та недоліків

4. **Швидкий тест**
   - Миттєве тестування зі стандартним набором

## Приклади результатів

### Бюджет 100 грн

#### Жадібний алгоритм
```
Вибрані страви: ['potato', 'cola', 'pepsi', 'hot-dog']
Загальна вартість: 80
Загальна калорійність: 870
Залишок бюджету: 20
```

#### Динамічне програмування
```
Вибрані страви: ['potato', 'cola', 'pepsi', 'hot-dog']
Загальна вартість: 80
Загальна калорійність: 870
Залишок бюджету: 20
```

### Бюджет 50 грн

#### Жадібний алгоритм
```
Вибрані страви: ['potato', 'cola', 'pepsi']
Загальна вартість: 50
Загальна калорійність: 670
```

#### Динамічне програмування
```
Вибрані страви: ['potato', 'cola', 'pepsi']
Загальна вартість: 50
Загальна калорійність: 670
```

## Аналіз продуктивності

### Часова складність

| Алгоритм | Час | Простір |
|----------|-----|---------|
| Жадібний | O(n log n) | O(n) |
| Динамічне програмування | O(n × W) | O(n × W) |

Де:
- n - кількість страв
- W - максимальний бюджет

### Практичні результати

#### Бюджет 100 грн
- **Жадібний**: 0.0001 сек, 870 кал
- **DP**: 0.0002 сек, 870 кал
- **Результат**: Однаковий (оптимальний)

#### Бюджет 200 грн
- **Жадібний**: 0.0001 сек, 1320 кал
- **DP**: 0.0003 сек, 1320 кал
- **Результат**: Однаковий (оптимальний)

### Візуалізація

Програма створює 4 графіки:

1. **Калорійність vs Бюджет**
   - Порівняння результатів обох алгоритмів
   - Показує, коли DP дає кращий результат

2. **Час виконання vs Бюджет**
   - Аналіз продуктивності
   - Демонструє перевагу жадібного алгоритму в швидкості

3. **Ефективність (калорії/секунда)**
   - Показує, який алгоритм ефективніший
   - Враховує як якість, так і швидкість

4. **Перевага DP**
   - Різниця в калорійності між алгоритмами
   - Показує, коли жадібний алгоритм неоптимальний

## Особливості реалізації

### Жадібний алгоритм
- Сортування за співвідношенням калорії/вартість
- Послідовний вибір найкращих страв
- Простий та зрозумілий код

### Динамічне програмування
- Двовимірна таблиця DP
- Рекурентне співвідношення
- Зворотний прохід для відновлення рішення

### Візуалізація
- Matplotlib для створення графіків
- 4 панелі з різними метриками
- Інтерактивні графіки

## Розширення

### Можливі покращення
1. **Додавання нових алгоритмів**:
   - Branch and Bound
   - Genetic Algorithm
   - Simulated Annealing

2. **Розширення функціональності**:
   - Обмеження на кількість страв
   - Множинні цілі (калорії + смак)
   - Інтерактивна візуалізація

3. **Оптимізація**:
   - Кешування результатів
   - Паралельне виконання
   - Покращення алгоритмів

### Інтеграція
- REST API для веб-додатків
- База даних для зберігання страв
- Мобільний додаток

## Тестування

### Автоматичні тести
```python
def test_greedy_algorithm():
    food_selection = FoodSelection()
    items, cost, calories = food_selection.greedy_algorithm(100, verbose=False)
    assert cost <= 100
    assert len(items) > 0

def test_dynamic_programming():
    food_selection = FoodSelection()
    items, cost, calories = food_selection.dynamic_programming(100, verbose=False)
    assert cost <= 100
    assert len(items) > 0
```

### Ручне тестування
- Різні бюджети (10, 50, 100, 200)
- Різні набори страв
- Граничні випадки (порожній бюджет, одна страва)

## Висновки

### Коли використовувати жадібний алгоритм
- ✅ Великі набори страв (>1000)
- ✅ Обмежена пам'ять
- ✅ Потрібне швидке приблизне рішення
- ✅ Простота реалізації важлива

### Коли використовувати динамічне програмування
- ✅ Невеликі бюджети (<1000)
- ✅ Потрібне оптимальне рішення
- ✅ Точність важливіша за швидкість
- ✅ Можна витратити більше пам'яті

### Практичні рекомендації
1. **Для швидкого прототипування** - використовуйте жадібний алгоритм
2. **Для продакшн систем** - використовуйте динамічне програмування
3. **Для великих даних** - комбінуйте підходи (спочатку жадібний, потім DP для уточнення)

## Залежності

- `matplotlib` - для візуалізації
- `numpy` - для числових обчислень
- `typing` - для типізації
- `time` - для вимірювання часу
- `random` - для генерації тестових даних

## Встановлення

```bash
pip install matplotlib numpy
```

## Ліцензія

Цей проект створено в навчальних цілях для демонстрації алгоритмів оптимізації.
![task6.png](img%2Ftask6.png)
![task6.1.png](img%2Ftask6.1.png)