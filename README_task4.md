# Завдання 4: Візуалізація піраміди (бінарної купи)

## Опис
Програма аналізує наданий код для візуалізації бінарних дерев та створює функцію для візуалізації бінарної купи. Використовується NetworkX та matplotlib для створення інтерактивних візуалізацій.

## Встановлення залежностей
```bash
pip install -r requirements.txt
```

## Використання

### Запуск програми
```bash
python task4.py
```

### Режими роботи
1. **Аналіз наданого коду** - детальний розбір оригінального коду
2. **Демонстрація операцій** - показує роботу з бінарною купою
3. **Інтерактивна демонстрація** - можливість самостійно досліджувати купу
4. **Тестування властивостей** - автоматична перевірка правильності
5. **Зразкове дерево** - демонстрація оригінального коду

## Аналіз наданого коду

### Клас Node
```python
class Node:
    def __init__(self, key, color="skyblue"):
        self.left = None
        self.right = None
        self.val = key
        self.color = color  # Колір для візуалізації
        self.id = str(uuid.uuid4())  # Унікальний ідентифікатор
```

**Особливості:**
- Зберігає значення вузла (`val`)
- Має посилання на нащадків (`left`, `right`)
- Унікальний ідентифікатор для NetworkX (`id`)
- Колір для візуалізації (`color`)

### Функція add_edges
```python
def add_edges(graph, node, pos, x=0, y=0, layer=1):
```

**Функціональність:**
- Рекурсивно обходить дерево
- Додає вузли до NetworkX графа
- Встановлює позиції для візуалізації
- Створює ребра між вузлами

**Алгоритм позиціонування:**
- Лівий нащадок: `x - 1/2^layer`
- Правий нащадок: `x + 1/2^layer`
- Кожен рівень зменшує відстань між вузлами

### Функція draw_tree
```python
def draw_tree(tree_root):
```

**Процес візуалізації:**
1. Створює NetworkX DiGraph
2. Витягує кольори та мітки з вузлів
3. Візуалізує з matplotlib
4. Показує дерево з підписами

## Реалізація бінарної купи

### Клас BinaryHeap
Розширює базовий функціонал для роботи з бінарною купою:

#### Основні операції:
- `insert(value)` - додавання елемента
- `extract_min()` - видалення мінімального елемента
- `peek()` - перегляд мінімального елемента
- `visualize()` - візуалізація купи

#### Внутрішні методи:
- `_heapify_up()` - відновлення властивості купи вгору
- `_heapify_down()` - відновлення властивості купи вниз
- `_rebuild_tree()` - перебудова дерева після змін

### Візуалізація купи

#### Особливості візуалізації:
- **Кольори по рівнях**: різні кольори для кожного рівня дерева
- **Динамічне оновлення**: дерево перебудовується після кожної операції
- **Інформативні заголовки**: показують операцію та поточний стан
- **Підтримка операцій**: візуалізація після вставки/видалення

#### Кольорова схема:
```python
colors = ['lightblue', 'lightgreen', 'lightcoral', 'lightyellow', 
         'lightpink', 'lightgray', 'lightsteelblue']
```

## Технічні деталі

### Властивості бінарної купи
1. **Heap Property**: батьківський елемент ≤ дочірніх елементів
2. **Повне бінарне дерево**: всі рівні заповнені, крім можливо останнього
3. **Мінімальний елемент**: завжди в корені дерева

### Алгоритми

#### Heapify Up (при вставці):
1. Додаємо елемент в кінець масиву
2. Порівнюємо з батьківським елементом
3. Якщо порушена властивість - міняємо місцями
4. Повторюємо до кореня

#### Heapify Down (при видаленні):
1. Замінюємо корінь останнім елементом
2. Порівнюємо з меншим з нащадків
3. Якщо порушена властивість - міняємо місцями
4. Повторюємо до листів

### Складність операцій
- **Вставка**: O(log n)
- **Видалення мінімуму**: O(log n)
- **Перегляд мінімуму**: O(1)
- **Візуалізація**: O(n)

## Приклади використання

### Базове використання
```python
from task4 import BinaryHeap

# Створення купи
heap = BinaryHeap()

# Додавання елементів
heap.insert(10)
heap.insert(5)
heap.insert(15)

# Візуалізація
heap.visualize("Моя купа")
```

### Демонстрація операцій
```python
# Вставка з візуалізацією
heap.insert(20)
heap.visualize_operation("Додано 20", 20)

# Видалення з візуалізацією
min_val = heap.extract_min()
heap.visualize_operation(f"Видалено {min_val}", min_val)
```

## Переваги реалізації

1. **Наслідування від базового коду**: використовує перевірені рішення
2. **Інтерактивність**: можливість експериментувати з купою
3. **Візуальна зворотність**: бачимо зміни після кожної операції
4. **Тестування**: автоматична перевірка властивостей
5. **Документація**: детальний аналіз оригінального коду

## Обробка помилок

- Перевірка порожньої купи
- Валідація введених даних
- Захист від неправильного вводу
- Обробка винятків при візуалізації

![task4.png](img%2Ftask4.png)
![task4.1.png](img%2Ftask4.1.png)